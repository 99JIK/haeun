---
slug: java-oop
title: Java 객체지향 4대 원칙 정리
authors: [haeun]
tags: [java, cs]
---

객체지향을 "클래스 만드는 거"로만 이해하고 있었는데, 제대로 정리하면서 왜 이런 원칙이 필요한지 이해하게 됐다.

<!-- truncate -->

## 1. 캡슐화 (Encapsulation)

데이터(필드)와 그 데이터를 다루는 메서드를 하나로 묶고, 외부에서 직접 접근을 막는 것.

```java
public class BankAccount {
    private int balance;  // 외부에서 직접 접근 불가

    public void deposit(int amount) {
        if (amount > 0) {
            this.balance += amount;
        }
    }

    public int getBalance() {
        return this.balance;
    }
}
```

`balance`를 `public`으로 열어두면 아무 데서나 음수를 넣을 수 있다. `private`으로 숨기고 메서드로만 접근하게 해서 **유효성 검증**을 보장한다.

## 2. 상속 (Inheritance)

기존 클래스를 확장해서 새로운 클래스를 만드는 것. 코드 재사용이 핵심.

```java
public class Animal {
    public void eat() { System.out.println("먹는다"); }
}

public class Dog extends Animal {
    public void bark() { System.out.println("멍멍"); }
}
```

주의할 점: 상속은 "is-a" 관계일 때만 사용. "has-a" 관계면 **합성(Composition)**이 더 적절하다.

## 3. 다형성 (Polymorphism)

같은 이름의 메서드가 상황에 따라 다르게 동작하는 것.

```java
public class Shape {
    public double area() { return 0; }
}

public class Circle extends Shape {
    private double radius;

    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}
```

인터페이스와 함께 쓰면 더 강력하다. 구현체를 바꿔도 호출하는 쪽 코드를 안 바꿔도 되니까.

## 4. 추상화 (Abstraction)

복잡한 내부 구현을 숨기고 필요한 인터페이스만 노출하는 것.

```java
public interface PaymentService {
    void pay(int amount);
}

// 내부 구현이 어떻든 사용하는 쪽에서는 pay()만 알면 됨
```

## 정리

| 원칙 | 핵심 | 키워드 |
|------|------|--------|
| 캡슐화 | 데이터 보호 | private, getter/setter |
| 상속 | 코드 재사용 | extends, is-a |
| 다형성 | 유연한 설계 | override, interface |
| 추상화 | 복잡도 숨김 | abstract, interface |
